import express from "express";
import { getSupabaseAdminClient } from "../lib/supabaseAdmin";
import { getUserAccessContextByAuthId } from "../lib/userAccess";
import type { PostgrestError } from "@supabase/supabase-js";
import type { EnterpriseDashboardResponse } from "../../shared/api";
import { getPlanByKey } from "../../shared/plans";

const enterpriseDashboardRouter = express.Router();

async function authorizeRequest(
  req: express.Request,
  res: express.Response,
  next: express.NextFunction,
) {
  const organizationIdRaw = req.query.organizationId;
  const authUserIdRaw =
    req.header("x-auth-user-id") ?? (req.query.authUserId as string | undefined);

  const organizationId =
    typeof organizationIdRaw === "string" ? organizationIdRaw.trim() : "";
  const authUserId = typeof authUserIdRaw === "string" ? authUserIdRaw.trim() : "";

  if (!organizationId || !authUserId) {
    res.status(400).json({ error: "organizationId and authUserId are required" });
    return;
  }

  try {
    const access = await getUserAccessContextByAuthId(authUserId);

    if (!access) {
      res.status(401).json({ error: "Unauthorized" });
      return;
    }

    const isOrgAdmin =
      access.organizationId === organizationId &&
      access.organizationRole === "org_admin";

    if (!access.isMaigonAdmin && !isOrgAdmin) {
      res.status(403).json({ error: "Forbidden" });
      return;
    }

    res.locals.organizationId = organizationId;
    res.locals.authUserId = authUserId;
    next();
  } catch (error) {
    console.error("[enterprise-dashboard] Authorization failure", error);
    res.status(500).json({ error: "Failed to authorize request" });
  }
}

enterpriseDashboardRouter.use(authorizeRequest);

function startOfCurrentQuarter(reference: Date): Date {
  const month = reference.getUTCMonth();
  const quarterStartMonth = Math.floor(month / 3) * 3;
  return new Date(Date.UTC(reference.getUTCFullYear(), quarterStartMonth, 1));
}

function handleError(error?: PostgrestError | null) {
  if (!error) return;
  throw error;
}

enterpriseDashboardRouter.get("/", async (req, res) => {
  const supabase = getSupabaseAdminClient();
  const organizationId: string = res.locals.organizationId;

  const now = new Date();
  const quarterStart = startOfCurrentQuarter(now);
  const monthStart = new Date(now);
  monthStart.setMonth(monthStart.getMonth() - 1);

  try {
    const [
      organizationResp,
      membersResp,
      activeMembersResp,
      contractsResp,
      contractsQuarterResp,
      reviewsRecentResp,
      autoGeneratedResp,
      analysisResp,
      recentContractsResp,
    ] = await Promise.all([
      supabase
        .from("organizations")
        .select("id, name, billing_plan, seats_limit, documents_limit")
        .eq("id", organizationId)
        .maybeSingle(),
      supabase
        .from("user_profiles")
        .select("id")
        .eq("organization_id", organizationId),
      supabase
        .from("user_profiles")
        .select("id")
        .eq("organization_id", organizationId)
        .eq("is_active", true),
      supabase
        .from("contracts")
        .select("id")
        .eq("organization_id", organizationId),
      supabase
        .from("contracts")
        .select("id")
        .eq("organization_id", organizationId)
        .gte("created_at", quarterStart.toISOString()),
      supabase
        .from("contract_reviews")
        .select("id")
        .eq("organization_id", organizationId)
        .gte("created_at", monthStart.toISOString()),
      supabase
        .from("contract_reviews")
        .select("id")
        .eq("organization_id", organizationId)
        .not("model_used", "is", null),
      supabase
        .from("analysis_metrics")
        .select("status, fallback_used")
        .eq("organization_id", organizationId)
        .gte("created_at", quarterStart.toISOString()),
      supabase
        .from("contracts")
        .select(
          "id, title, status, created_at, user_profiles:user_id(first_name,last_name,email)"
        )
        .eq("organization_id", organizationId)
        .order("created_at", { ascending: false })
        .limit(8),
    ]);

    handleError(organizationResp.error);
    handleError(membersResp.error);
    handleError(activeMembersResp.error);
    handleError(contractsResp.error);
    handleError(contractsQuarterResp.error);
    handleError(reviewsRecentResp.error);
    handleError(autoGeneratedResp.error);
    handleError(analysisResp.error);
    handleError(recentContractsResp.error);

    const organization = organizationResp.data;
    if (!organization) {
      res.status(404).json({ error: "Organization not found" });
      return;
    }

    const members = membersResp.data ?? [];
    const activeMembers = activeMembersResp.data ?? [];
    const contracts = contractsResp.data ?? [];
    const contractsQuarter = contractsQuarterResp.data ?? [];
    const recentReviews = reviewsRecentResp.data ?? [];
    const autoGenerated = autoGeneratedResp.data ?? [];
    const analysisRows = analysisResp.data ?? [];
    const recentContracts = recentContractsResp.data ?? [];

    const plan = organization.billing_plan
      ? getPlanByKey(organization.billing_plan)
      : null;

    const fallbackUsed = analysisRows.filter((row) => row.fallback_used).length;
    const riskStatus = analysisRows
      .map((row) => row.status ?? "unknown")
      .reduce<Record<string, number>>((acc, status) => {
        acc[status] = (acc[status] ?? 0) + 1;
        return acc;
      }, {});

    const response: EnterpriseDashboardResponse = {
      organization: {
        id: organization.id,
        name: organization.name,
        planKey: organization.billing_plan ?? null,
        planName: plan?.name ?? organization.billing_plan ?? null,
        seatsLimit: organization.seats_limit ?? null,
        documentsLimit: organization.documents_limit ?? null,
      },
      overview: {
        totalMembers: members.length,
        activeMembers: activeMembers.length,
        contractsTotal: contracts.length,
        contractsThisQuarter: contractsQuarter.length,
        autoGeneratedReports: autoGenerated.length,
        recentReviews: recentReviews.length,
      },
      adoption: [
        {
          label: "Active Members",
          value: activeMembers.length,
          hint: organization.seats_limit
            ? `${activeMembers.length}/${organization.seats_limit} seats`
            : null,
        },
        {
          label: "Total Contracts",
          value: contracts.length,
          hint: "All-time",
        },
        {
          label: "Contracts This Quarter",
          value: contractsQuarter.length,
          hint: "Quarter to date",
        },
      ],
      risk: {
        fallbackRatePct:
          analysisRows.length > 0
            ? Math.round((fallbackUsed / analysisRows.length) * 10000) / 100
            : null,
        statusBreakdown: Object.entries(riskStatus).map(([status, count]) => ({
          status,
          count,
        })),
      },
      recentContracts: recentContracts.map((row) => {
        const profile = (row as any).user_profiles ?? null;
        const owner = profile
          ? `${profile.first_name ?? ""} ${profile.last_name ?? ""}`
              .trim()
              .replace(/\s+/g, " ") || profile.email || null
          : null;
        return {
          id: row.id,
          title: row.title,
          status: row.status ?? null,
          createdAt: row.created_at ?? null,
          owner,
        };
      }),
      updatedAt: now.toISOString(),
    } satisfies EnterpriseDashboardResponse;

    res.json(response);
  } catch (error) {
    console.error("[enterprise-dashboard] Failed to compute overview", error);
    res.status(500).json({ error: "Failed to load enterprise dashboard" });
  }
});

export { enterpriseDashboardRouter };
